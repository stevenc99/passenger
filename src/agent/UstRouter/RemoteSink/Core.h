/*
 *  Phusion Passenger - https://www.phusionpassenger.com/
 *  Copyright (c) 2010-2016 Phusion Holding B.V.
 *
 *  "Passenger", "Phusion Passenger" and "Union Station" are registered
 *  trademarks of Phusion Holding B.V.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
#ifndef _PASSENGER_UST_ROUTER_REMOTE_SINK_CORE_H_
#define _PASSENGER_UST_ROUTER_REMOTE_SINK_CORE_H_

namespace Passenger {
namespace UstRouter {
namespace RemoteSink {

#include <cstddef>
#include <UstRouter/Sink.h>

using namespace std;
using namespace boost;
using namespace oxt;


/**
 * ## Lock ordering
 *
 * 1. Core::syncher
 * 2. Thread::syncher
 */
class Core: public Sink {
private:
	size_t maxQueueSize;

	// These fields may only be accessed from the event loop.
	TransactionList incomingTransactions;


	// All fields past this point are protected by the syncher.

	boost::mutex syncher;
	size_t bytesIncoming;
	unsigned int nIncoming;
	TransactionList incoming;

	BatchList<16> sending;


	/*
	 * A packet is first generated by Core::schedule(). The counter is incremented there.
	 *
	 * This counter increases monotonically.
	 */
	Counter packetsGenerated;
	/**
	 * Core::schedule() will attempt to put the packet in the queue. If it is successful,
	 * this counter is incremented. Otherwise, `packetsDropped` is incremented.
	 *
	 * This counter decreases when a thread takes a packet out of the queue.
	 */
	Counter packetsQueued;
	/**
	 * This counter increases when a thread takes a packet out of the queue, decreases
	 * when the thread is done sending that packet.
	 */
	Counter packetsSending;
	/**
	 * When a thread has sent a packet to a gateway server, and that server replied with
	 * a success message, then this counter is incremented.
	 *
	 * This counter increases monotonically.
	 */
	Counter packetsAccepted;
	/**
	 * When a thread has sent a packet to a gateway server, and that server explicitly
	 * replied with a message indicating that the packet is not accepted, then this
	 * counter is incremented.
	 *
	 * This counter increases monotonically.
	 */
	Counter packetsRejected;
	/**
	 * When a thread was unable to contact any gateway server to send a packet to (e.g.
	 * because of TCP errors, or all servers only responded with gibberish), or if
	 * Core::schedule() was unable to put a packet in the queue, then this
	 * counter is incremented.
	 *
	 * This counter increases monotonically.
	 */
	Counter packetsDropped;


public:
	Core(const VariantMap &options)
		: maxQueueSize(options.getULL("max_queue_size"))
	{

	}

	~Core() {

	}

	virtual void schedule(Transaction *transaction) {
		Sink::schedule(transaction);
		STAILQ_INSERT_TAIL(&incoming, transaction, next);
		bytesIncoming += transaction->getBody().size();
		nIncoming++;
	}

	virtual void flush() {
		Sink::flush();
		batcher.add(&incoming, bytesIncoming, nIncoming, ev_now(loop));
		assert(STAILQ_EMPTY(&incoming));
		bytesIncoming = 0;
		nIncoming = 0;
	}

	Json::Value inspectIncomingStateAsJson() const {
		Json::Value doc;

		doc["total_size"] = byteSizeToJson(bytesIncoming);
		doc["total_count"] = nIncoming;
		return doc;
	}

	virtual Json::Value inspectStateAsJson() const {
		Json::Value doc;
		boost::lock_guard<boost::mutex> l(syncher);

		doc["incoming"] = inspectIncomingStateAsJson();
		doc["batching"] = batcher.inspectStateAsJson();
		doc["sending"]  = sender.inspectStateAsJson();


		serverList->inspectStateAsJson(doc);
/*		doc["queue_size"] = byteSizeToJson(bytesQueued);
		doc["threads"] = liveThreads;
		doc["packets_generated"] = packetsGenerated.inspectAsJson();
		doc["packets_queued"] = packetsQueued.inspectAsJson();
		doc["packets_sending"] = packetsSending.inspectAsJson();
		doc["packets_accepted"] = packetsAccepted.inspectAsJson();
		doc["packets_rejected"] = packetsRejected.inspectAsJson();
		doc["packets_dropped"] = packetsDropped.inspectAsJson(); */
		/* if (certificate.empty()) {
			doc["certificate"] = Json::nullValue;
		} else {
			doc["certificate"] = certificate;
		}
		doc["up_servers"] = serverList->inspectUpServersStateAsJson();
		doc["down_servers"] = serverList->inspectDownServersStateAsJson();
		if (lastCheckupTime == 0) {
			doc["last_server_checkup_time"] = Json::Value(Json::nullValue);
			doc["last_server_checkup_time_note"] = "not yet started";
		} else {
			doc["last_server_checkup_time"] = timeToJson(lastCheckupTime * 1000000.0);
		}
		if (nextCheckupTime == 0) {
			doc["next_server_checkup_time"] = Json::Value(Json::nullValue);
			doc["next_server_checkup_time_note"] = "not yet scheduled, waiting for first packet";
		} else {
			doc["next_server_checkup_time"] = timeToJson(nextCheckupTime * 1000000.0);
		}
		if (!lastDnsErrorMessage.empty()) {
			doc["last_dns_error_message"] = lastDnsErrorMessage;
		} */
		return doc;
	}
};


} // namespace RemoteSink
} // namespace UstRouter
} // namespace Passenger

#endif /* _PASSENGER_UST_ROUTER_REMOTE_SINK_CORE_H_ */
